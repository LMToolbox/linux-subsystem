name: Build Alpine Rootfs

on:
  schedule:
    - cron: '0 2 * * *' # Daily at 02:00 UTC
  workflow_dispatch:
    inputs:
      alpine_version:
        description: "Alpine version"
        required: false
        default: "3.22.2"
      force_release:
        description: "Force release even if no changes?"
        type: boolean
        default: false

permissions:
  contents: write # Required to read tags and create Releases

env:
  DEFAULT_ALPINE_VERSION: "3.22.2"

jobs:
  # ------------------------------------------------------------------
  # JOB 1: Calculate Version ID
  # ------------------------------------------------------------------
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.calc_ver.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate Next Version
        id: calc_ver
        run: |
          BASE_VER=$(date +'%y.%m.%d')
          NEW_TAG="$BASE_VER"
          
          # Note: This naturally ignores "proot-" tags because they don't start with the date (BASE_VER)
          EXISTING_TAGS=$(git tag -l "${BASE_VER}*")
          
          if [[ "$EXISTING_TAGS" == *"$BASE_VER"* ]]; then
             for suffix in a b c d e f g; do
               if [[ "$EXISTING_TAGS" != *"${BASE_VER}${suffix}"* ]]; then
                 NEW_TAG="${BASE_VER}${suffix}"
                 break
               fi
             done
          fi
          
          echo "version=$NEW_TAG" >> $GITHUB_OUTPUT

  # ------------------------------------------------------------------
  # JOB 2: Build & Compare
  # ------------------------------------------------------------------
  build:
    name: Build ${{ matrix.arch }}
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x86_64
            platform: linux/amd64
          - arch: aarch64
            platform: linux/arm64/v8
          - arch: arm
            platform: linux/arm/v7

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set Environment
        run: |
          if [ -n "${{ inputs.alpine_version }}" ]; then
            echo "ALPINE_VERSION=${{ inputs.alpine_version }}" >> $GITHUB_ENV
          else
            echo "ALPINE_VERSION=${{ env.DEFAULT_ALPINE_VERSION }}" >> $GITHUB_ENV
          fi

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # --- Fetch Previous Manifest (Filtered) ---
      - name: Fetch Previous Manifest
        id: prev_manifest
        env:
          GH_TOKEN: ${{ github.token }}
          ARCH: ${{ matrix.arch }}
        run: |
          # Logic Update:
          # 1. List the last 10 releases (to look past any recent proot- releases)
          # 2. Use jq to select tags that do NOT start with "proot-"
          # 3. Take the top one (head -n 1)
          
          LATEST_TAG=$(gh release list --limit 10 --exclude-drafts --exclude-pre-releases --json tagName \
            --jq '.[] | select(.tagName | startswith("proot-") | not) | .tagName' | head -n 1 || echo "")
          
          echo "has_prev=false" >> $GITHUB_OUTPUT
          
          if [ -n "$LATEST_TAG" ]; then
             echo "Found latest relevant release: $LATEST_TAG"
             
             # Download ONLY the tiny manifest file
             if gh release download "$LATEST_TAG" -p "manifest-${ARCH}.txt" -O prev-manifest.txt; then
                 echo "Found previous manifest."
                 echo "has_prev=true" >> $GITHUB_OUTPUT
             else
                 echo "Warning: Release $LATEST_TAG found, but no manifest for $ARCH."
             fi
          else
             echo "No relevant previous releases found."
          fi

      # --- Build Rootfs ---
      - name: Build Rootfs
        env:
          PLATFORM: ${{ matrix.platform }}
          ARCH: ${{ matrix.arch }}
          IMAGE_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          mkdir -p out
          PKGS=$(grep -Ev '^\s*#|^\s*$' pkgs.txt | tr '\n' ' ' || echo "")
          
          docker run --platform "$PLATFORM" \
            -e PKGS="$PKGS" \
            -v $(pwd)/out:/out \
            --name rootfs alpine:"${ALPINE_VERSION}" sh -euxc "
            
            apk -U upgrade --no-cache
            if [ -n \"$PKGS\" ]; then apk add --no-cache $PKGS; fi
            
            echo \"$IMAGE_VERSION\" > /etc/image-version
            chmod 644 /etc/image-version
            
            # Generate manifest
            apk info -v | sort > /out/manifest-${ARCH}.txt
            
            rm -rf /var/cache/apk/* /usr/share/man /usr/share/doc /usr/share/locale /tmp/*
            mkdir -p /proc /sys /dev
          "
          
          # Export raw rootfs
          docker export rootfs | gzip -c > "out/alpine-rootfs-${ARCH}.tar.gz"

      # --- Compare Logic ---
      - name: Compare Packages
        id: compare
        env:
          ARCH: ${{ matrix.arch }}
          HAS_PREV: ${{ steps.prev_manifest.outputs.has_prev }}
        run: |
          CHANGED="false"
          CHANGELOG=""

          if [ "$HAS_PREV" == "false" ]; then
            CHANGED="true"
            CHANGELOG="Initial release / Full rebuild."
          else
            DIFF=$(comm -3 prev-manifest.txt out/manifest-${ARCH}.txt)
            if [ -n "$DIFF" ]; then
              CHANGED="true"
              CHANGELOG+="### Changes for ${ARCH}"$'\n'
              CHANGELOG+="| Status | Package |"$'\n| :--- | :--- |'$'\n'
              while IFS= read -r line; do
                clean=$(echo "$line" | xargs)
                if [[ "$line" == $'\t'* ]]; then
                  CHANGELOG+="| ðŸŸ¢ Up | \`$clean\` |"$'\n'
                else
                  CHANGELOG+="| ðŸ”´ Rm | \`$clean\` |"$'\n'
                fi
              done <<< "$DIFF"
            fi
          fi
          
          if [ "${{ inputs.force_release }}" == "true" ]; then CHANGED="true"; fi
          
          echo "changed=$CHANGED" >> $GITHUB_OUTPUT
          {
            echo "changelog<<EOF"
            echo "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Upload Artifacts & State
        uses: actions/upload-artifact@v4
        with:
          name: build-data-${{ matrix.arch }}
          path: |
            out/alpine-rootfs-${{ matrix.arch }}.tar.gz
            out/manifest-${{ matrix.arch }}.txt
            
      - name: Save Build State
        run: |
          mkdir -p state
          echo "${{ steps.compare.outputs.changed }}" > state/${{ matrix.arch }}.changed
          echo "${{ steps.compare.outputs.changelog }}" > state/${{ matrix.arch }}.log
      - uses: actions/upload-artifact@v4
        with:
          name: state-${{ matrix.arch }}
          path: state/*

  # ------------------------------------------------------------------
  # JOB 3: Release
  # ------------------------------------------------------------------
  release:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download State
        uses: actions/download-artifact@v4
        with:
          pattern: state-*
          path: states
          merge-multiple: true

      - name: Check if Release Needed
        id: check
        run: |
          if grep -q "true" states/*.changed; then
            echo "needed=true" >> $GITHUB_OUTPUT
            echo "full_log<<EOF" >> $GITHUB_OUTPUT
            cat states/*.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "needed=false" >> $GITHUB_OUTPUT
            echo "No changes detected. Skipping release."
          fi

      - name: Download Build Artifacts
        if: steps.check.outputs.needed == 'true'
        uses: actions/download-artifact@v4
        with:
          pattern: build-data-*
          path: raw_assets
          merge-multiple: true

      - name: Package Artifacts
        if: steps.check.outputs.needed == 'true'
        run: |
          mkdir -p final_package
          
          # Function to move and rename assets
          package_arch() {
            local SRC_ARCH=$1
            local DEST_DIR=$2
            
            mkdir -p "final_package/$DEST_DIR"
            
            # Move and Rename Rootfs
            if [ -f "raw_assets/alpine-rootfs-${SRC_ARCH}.tar.gz" ]; then
              mv "raw_assets/alpine-rootfs-${SRC_ARCH}.tar.gz" \
                 "final_package/$DEST_DIR/libalpine-rootfs.tar.gz.so"
            fi
          }

          # Map build artifacts to Android ABI folder names
          package_arch "x86_64"  "x86_64"
          package_arch "aarch64" "arm64-v8a"
          package_arch "arm"     "armeabi-v7a"

          echo "==> Creating Master Archive..."
          tar -czf alpine-rootfs.tar.gz -C final_package .
          
          ls -R final_package
          ls -lh alpine-rootfs.tar.gz

      - name: Push Release
        if: steps.check.outputs.needed == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.version }}
          name: Release ${{ needs.prepare.outputs.version }}
          body: |
              ## Automated Build ${{ needs.prepare.outputs.version }}
              Base Alpine: ${{ env.DEFAULT_ALPINE_VERSION }}
              
              ${{ steps.check.outputs.full_log }}
          files: |
            alpine-rootfs.tar.gz
            raw_assets/manifest-*.txt
          make_latest: true
