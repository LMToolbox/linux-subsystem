name: Build Alpine Rootfs

on:
  schedule:
    - cron: '0 2 * * *' # Daily at 02:00 UTC
  workflow_dispatch:
    inputs:
      alpine_version:
        description: "Alpine version"
        required: false
        default: "3.22.2"
      force_release:
        description: "Force release even if no changes?"
        type: boolean
        default: false

permissions:
  contents: write

env:
  DEFAULT_ALPINE_VERSION: "3.22.2"

jobs:
  # ------------------------------------------------------------------
  # JOB 1: Calculate Version ID
  # ------------------------------------------------------------------
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.calc_ver.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Calculate Next Version
        id: calc_ver
        run: |
          BASE_VER=$(date +'%y.%m.%d')
          NEW_TAG="$BASE_VER"
          EXISTING_TAGS=$(git tag -l "${BASE_VER}*")
           
          if [[ "$EXISTING_TAGS" == *"$BASE_VER"* ]]; then
             for suffix in a b c d e f g; do
               if [[ "$EXISTING_TAGS" != *"${BASE_VER}${suffix}"* ]]; then
                 NEW_TAG="${BASE_VER}${suffix}"
                 break
               fi
             done
          fi
          echo "version=$NEW_TAG" >> $GITHUB_OUTPUT

  # ------------------------------------------------------------------
  # JOB 2: Build (Parallel)
  # ------------------------------------------------------------------
  build:
    name: Build ${{ matrix.arch }}
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x86_64
            platform: linux/amd64
          - arch: aarch64
            platform: linux/arm64/v8
          - arch: arm
            platform: linux/arm/v7

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set Environment
        run: |
          if [ -n "${{ inputs.alpine_version }}" ]; then
            echo "ALPINE_VERSION=${{ inputs.alpine_version }}" >> $GITHUB_ENV
          else
            echo "ALPINE_VERSION=${{ env.DEFAULT_ALPINE_VERSION }}" >> $GITHUB_ENV
          fi

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build Rootfs
        env:
          PLATFORM: ${{ matrix.platform }}
          ARCH: ${{ matrix.arch }}
          IMAGE_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          mkdir -p out
           
          if [ -f config.yaml ]; then
            APK_PKGS=$(yq -r '.apk[] // ""' config.yaml | tr '\n' ' ')
            PIP_PKGS=$(yq -r '.pip[] // ""' config.yaml | tr '\n' ' ')
          else
            echo "No config.yaml found!"
            exit 1
          fi

          # We explicitly sort the manifests inside the container to ensure determinism
          docker run --platform "$PLATFORM" \
            -e APK_PKGS="$APK_PKGS" \
            -e PIP_PKGS="$PIP_PKGS" \
            -v $(pwd)/out:/out \
            --name rootfs alpine:"${ALPINE_VERSION}" sh -euxc "
           
            apk -U upgrade --no-cache
           
            # 1. Install User Runtime APK Packages
            if [ -n \"\$APK_PKGS\" ]; then 
              apk add --no-cache \$APK_PKGS
            fi
           
            # 2. Handle PIP Packages
            if [ -n \"\$PIP_PKGS\" ]; then
              apk add --no-cache --virtual .build-deps py3-pip python3-dev
              pip install --no-cache-dir --break-system-packages \$PIP_PKGS
              
              # Manifest PIP (Before cleanup)
              pip freeze | sort > /out/manifest-pip-${ARCH}.txt
              
              apk del .build-deps
            else
              touch /out/manifest-pip-${ARCH}.txt
            fi
           
            echo \"$IMAGE_VERSION\" > /etc/image-version
            chmod 644 /etc/image-version
           
            # 3. Generate APK Manifest
            apk info -v | sort > /out/manifest-apk-${ARCH}.txt
           
            # Cleanup
            rm -rf /var/cache/apk/* /usr/share/man /usr/share/doc /usr/share/locale /tmp/* /root/.cache
            mkdir -p /proc /sys /dev
          "
           
          docker export rootfs | gzip -c > "out/alpine-rootfs-${ARCH}.tar.gz"

      - name: Upload Artifacts
        uses: actions/upload-artifact@v5
        with:
          name: build-data-${{ matrix.arch }}
          path: |
            out/alpine-rootfs-${{ matrix.arch }}.tar.gz
            out/manifest-apk-${{ matrix.arch }}.txt
            out/manifest-pip-${{ matrix.arch }}.txt

  # ------------------------------------------------------------------
  # JOB 3: Release & Compare
  # ------------------------------------------------------------------
  release:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:

      - name: Checkout
        uses: actions/checkout@v5

      - name: Download Current Build Artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: build-data-*
          path: current_assets
          merge-multiple: true

      - name: Fetch Previous Release Manifests
        id: fetch_prev
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p prev_assets
          
          # 1. Find latest release (Filter out 'proot-')
          # We fetch the last 20 tags, filter out any starting with "proot-", and take the top one.
          LATEST_TAG=$(gh release list --limit 20 --exclude-drafts --exclude-pre-releases --json tagName \
            --jq '.[] | select(.tagName | startswith("proot-") | not) | .tagName' | head -n 1 || echo "")
          
          echo "Latest detected tag: [$LATEST_TAG]"
          
          if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" == "null" ]; then
            echo "is_initial=true" >> $GITHUB_OUTPUT
            echo "::notice::No previous release found."
          else
            echo "is_initial=false" >> $GITHUB_OUTPUT
            
            # 2. Attempt to download manifests (Strict Naming)
            for arch in x86_64 aarch64 arm; do
              # APK
              if ! gh release download "$LATEST_TAG" -p "manifest-apk-${arch}.txt" -O "prev_assets/manifest-apk-${arch}.txt" 2>/dev/null; then
                 echo "No strict APK manifest found for $arch. Treating as new."
                 touch "prev_assets/manifest-apk-${arch}.txt"
              fi

              # PIP
              if ! gh release download "$LATEST_TAG" -p "manifest-pip-${arch}.txt" -O "prev_assets/manifest-pip-${arch}.txt" 2>/dev/null; then
                 touch "prev_assets/manifest-pip-${arch}.txt"
              fi
            done
          fi

      - name: Generate Unified Changelog
        id: changelog
        run: |
          mkdir -p rows
          CHANGES_DETECTED="false"
          
          # Function: Generate sorted table rows for a single arch
          # Outputs to file: rows/{arch}.txt
          generate_rows() {
            local arch=$1
            local outfile="rows/${arch}.txt"
            touch "$outfile"

            process_diff() {
              local old=$1
              local new=$2
              [ -f "$old" ] || touch "$old"
              [ -f "$new" ] || touch "$new"
              sort -o "$old" "$old"
              sort -o "$new" "$new"
              
              comm -3 "$old" "$new" | awk -F'\t' '
                 length($1) > 0 { print "| ðŸ”´ Rm | `" $1 "` |" }
                 length($2) > 0 { print "| ðŸŸ¢ Up | `" $2 "` |" }
               '
            }
            
            # Capture APK changes
            process_diff "prev_assets/manifest-apk-${arch}.txt" "current_assets/manifest-apk-${arch}.txt" >> "$outfile"
            # Capture PIP changes
            process_diff "prev_assets/manifest-pip-${arch}.txt" "current_assets/manifest-pip-${arch}.txt" >> "$outfile"
            
            # Sort the result to ensure deterministic comparisons later
            sort -o "$outfile" "$outfile"
            
            if [ -s "$outfile" ]; then
              CHANGES_DETECTED="true"
            fi
          }

          # 1. Generate raw rows for all arches
          generate_rows "x86_64"
          generate_rows "aarch64"
          generate_rows "arm"

          # 2. Build Final Log
          FINAL_LOG=""

          if [ "${{ steps.fetch_prev.outputs.is_initial }}" == "true" ]; then
             CHANGES_DETECTED="true"
             FINAL_LOG="Initial Release."
          elif [ "$CHANGES_DETECTED" == "true" ]; then
             
             # --- MAIN TABLE (x86_64) ---
             if [ -s "rows/x86_64.txt" ]; then
               FINAL_LOG+="### ðŸš€ Changes"$'\n'
               FINAL_LOG+="| Status | Package |"$'\n'
               FINAL_LOG+="| :--- | :--- |"$'\n'
               FINAL_LOG+=$(cat "rows/x86_64.txt")
             else
               FINAL_LOG+="No changes in x86_64 (Main)."
             fi
             
             # --- DIFF TABLES (Others) ---
             # Function to append diff table
             append_arch_diff() {
               local arch=$1
               local main_file="rows/x86_64.txt"
               local arch_file="rows/${arch}.txt"
               local unique_file="rows/${arch}_unique.txt"
               
               # Finds lines in arch_file that are NOT in main_file
               # comm -13: suppress col 1 (unique to main) and col 3 (common)
               # Output: Column 2 (Unique to Arch)
               comm -13 "$main_file" "$arch_file" > "$unique_file"
               
               if [ -s "$unique_file" ]; then
                  FINAL_LOG+=$'\n\n'"### ðŸ“¦ ${arch} Specifics"$'\n'
                  FINAL_LOG+="| Status | Package |"$'\n'
                  FINAL_LOG+="| :--- | :--- |"$'\n'
                  FINAL_LOG+=$(cat "$unique_file")
               fi
             }

             append_arch_diff "aarch64"
             append_arch_diff "arm"
          fi

          # Force release override
          if [ "${{ inputs.force_release }}" == "true" ]; then CHANGES_DETECTED="true"; fi

          echo "needed=$CHANGES_DETECTED" >> $GITHUB_OUTPUT
          echo "full_log<<EOF" >> $GITHUB_OUTPUT
          echo "$FINAL_LOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Package Artifacts
        if: steps.changelog.outputs.needed == 'true'
        run: |
          mkdir -p final_package
          
          package_arch() {
            local SRC_ARCH=$1
            local DEST_DIR=$2
            mkdir -p "final_package/$DEST_DIR"
            if [ -f "current_assets/alpine-rootfs-${SRC_ARCH}.tar.gz" ]; then
              mv "current_assets/alpine-rootfs-${SRC_ARCH}.tar.gz" \
                 "final_package/$DEST_DIR/libalpine-rootfs.tar.gz.so"
            fi
          }

          package_arch "x86_64"  "x86_64"
          package_arch "aarch64" "arm64-v8a"
          package_arch "arm"     "armeabi-v7a"

          echo "==> Creating Master Archive..."
          tar -czf alpine-rootfs.tar.gz -C final_package .

      - name: Push Release
        if: steps.changelog.outputs.needed == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.version }}
          name: Release ${{ needs.prepare.outputs.version }}
          body: |
              ## Automated Build ${{ needs.prepare.outputs.version }}
              Base Alpine: ${{ env.DEFAULT_ALPINE_VERSION }}
              
              ${{ steps.changelog.outputs.full_log }}
          files: |
            alpine-rootfs.tar.gz
            current_assets/manifest-*.txt
          make_latest: true
